# Architecture Design Document

## 1. System Overview

### 1.1 Application Configuration

- Desktop Application Version
  - Frontend: SvelteKit (SSG+CSR)
  - Backend: Tauri
  - Database: SQLite
- Web Application Version
  - Frontend: SvelteKit (SSG+CSR)
  - Backend: Experimental Web backend stub (`src/lib/infrastructure/backends/web`)
  - Database: Not in production use (future plan)

### 1.2 Main Components

- UI Layer
  - Components: Svelte + shadcn-svelte
  - State Management:
    - Reactive stores (`src/lib/stores/…`) cache view state only (e.g., `ViewStore`, `TaskDetailViewStore`)
    - UI services (`src/lib/services/ui/…`) encapsulate side effects, orchestration, and cross-store coordination
  - Routing: SvelteKit
- Business Logic Layer
  - Task management
  - Project management
  - Synchronization processing
- Data Access Layer
  - Data structure based on AutoMerge
  - Local (Tauri app): SQLite is added, data search uses SQLite only, data updates are saved in order of SQLite, Automerge
  - Web: Experimental backend path only, disabled by default (requires `PUBLIC_ENABLE_EXPERIMENTAL_WEB_BACKEND=true`)
  - Cloud storage (Automerge) synchronization support
  - Future support for Git synchronization

## 2. Desktop Application Architecture

### 2.1 SvelteKit+Tauri Architecture

- Frontend (SvelteKit)
  - Static files generated by SSG
  - Dynamic updates via CSR
  - Display in WebView
- Backend (Tauri/Rust) - Crate separation architecture
  - **flequit (main crate)**: Tauri commands, system API integration, OS features
  - **flequit-core (business logic)**: Service layer, facade layer
  - **flequit-storage (storage layer)**: Repository, database operations, file I/O
  - Each crate can be built and tested independently

### 2.2 Data Flow

- Local-first approach
  - Immediate reflection of local data
  - Background synchronization
  - Offline support
- SQLite database
  - WAL (Write-Ahead Logging) mode
  - In-memory cache
  - Transaction optimization

### 2.3 First-Launch Data Bootstrap

- On startup, backend initialization commands perform a minimum data check before returning account/project payloads.
- If non-deleted data does not exist for each entity, create only the missing minimum records:
  - User: `Local user`
  - Account: `Local Account` (provider: `local`)
  - Project: `My Tasks`
- Initialization is idempotent:
  - Existing user data is not overwritten.
  - Existing account data is not overwritten.
  - Existing project data is not overwritten.
- This bootstrap is triggered by startup read commands (e.g. account/project load) so an empty local DB can still reach task creation flow.

## 3. Web Application Architecture (Experimental)

### 3.1 Current Position

- Frontend (SvelteKit)
  - Static site generation
  - Client-side rendering
  - Not the default runtime path in this repository
- Backend
  - Experimental web backend stubs under `src/lib/infrastructure/backends/web`
  - Activated only when `PUBLIC_ENABLE_EXPERIMENTAL_WEB_BACKEND=true`
  - Local-first Tauri path remains the default

### 3.2 Future Direction

- Potential cloud backend candidates (e.g., Supabase) remain future options.
- Until a production web backend is defined, web path behavior is intentionally limited and marked as experimental.

## 4. Performance Optimization

### 4.1 Frontend Optimization

- Bundle size minimization
  - Code splitting
  - Lazy loading
  - Asset optimization
- Rendering optimization
  - Virtual scrolling
  - Memoization
  - Rendering throttling

### 4.2 Backend Optimization

- Database performance
  - Index optimization
  - Query optimization
  - Connection pooling
- Caching strategy
  - Memory cache
  - Query cache
  - Result cache

## 5. Scalability Design

### 5.1 Desktop Application

- Efficient resource usage
  - Memory usage optimization
  - CPU load distribution
  - Disk I/O optimization
- Data synchronization efficiency
  - Batch processing
  - Differential synchronization
  - Priority control

### 5.2 Web Application

- Horizontal scaling
  - Stateless design
  - Load balancing
  - Sharding
- Vertical scaling
  - Resource optimization
  - Performance tuning
  - Bottleneck elimination

## 6. Security Architecture

### 6.1 Desktop Application

- Tauri security features
  - CSP (Content Security Policy)
  - Sandboxing
  - Encrypted storage
- Data protection
  - File encryption
  - Secure communication
  - Access control

### 6.2 Web Application

- Supabase security features
  - RLS (Row Level Security)
  - JWT authentication
  - SSL/TLS encryption
- Application security
  - XSS countermeasures
  - CSRF countermeasures
  - Input validation

## 7. Monitoring and Operations

### 7.1 Monitoring

- Performance monitoring
  - Response time
  - Resource usage rate
  - Error rate
- User experience monitoring
  - Core Web Vitals
  - Crash reports
  - Usage statistics

### 7.2 Operations Management

- Log management
  - Error logs
  - Access logs
  - Audit logs
- Backup
  - Data backup
  - Configuration backup
  - Restore procedures
