## 開発ワークフロー

### 推奨手順

PR運用の基本ルール:
- 変更の設計判断に関係する場合、ドキュメント変更を同梱（該当なしはN/Aを明記）
- PR説明に「適用パターン/回避アンチパターン」を記述（PRテンプレ参照）
- レビューチェックリストを満たすこと（component-patterns / anti-patterns 参照）

手順の過程でエラーが発生した場合、解消後に次工程に進む

#### フロントエンド（SvelteKit）のコード修正時

1. コード編集
2. vitest単体テストケース作成
3. `bun check` - 型チェック実行
4. `bun run lint` - リンター実行
5. `bun run test [単体テストファイル名]` - vitest単体テスト実行
6. vitest結合テストケース作成
7. `bun run test [結合テストファイル名]` - vitest結合テスト実行
8. `bun run test` - vitest全テスト実行
9. Playwright(E2E)テストケース作成
10. `bun run test:e2e [E2Eテストファイル名]` - E2Eテスト実行（個別ファイルのみで全体は実行しない）

##### 詳細手順

###### 1. コード編集
- **実装方針確認**: 関連する設計ドキュメント（`docs/develop/design/frontend/`）を確認
- **既存コード分析**: 修正対象ファイルと関連ファイルの構造を把握
- **段階的実装**: 小さな単位で実装し、都度動作確認
- **型安全性確保**: TypeScriptの型チェックを意識した実装
- **動作しない場合の対処**:
  - ブラウザのデベロッパーツールでエラー確認
  - `bun run dev` でホットリロードによる即座の確認
  - console.log等によるデバッグログの追加
  - 関連する既存テストの実行で影響範囲を確認

###### 2. vitest単体テストケース作成
- **テスト対象の特定**: 作成・修正した関数、コンポーネントの公開インターフェースを洗い出し
- **テストケース設計**: 
  - 正常系: 期待される入力に対する正しい出力の確認
  - 異常系: エラー条件や境界値でのふるまい確認
  - エッジケース: null、undefined、空文字等の特殊値での動作確認
- **テストファイル作成**: `*.test.ts` または `*.spec.ts` の命名規則に従う
- **テストが書けない場合の対処**:
  - 対象コードの依存関係が複雑 → モック化を検討
  - 外部APIへの依存 → MSW等によるモック化
  - UIコンポーネントのテスト → Testing Libraryのレンダリングテスト

###### 6. vitest結合テストケース作成
- **結合テスト対象の特定**: 複数コンポーネント間の連携、ストアとの結合等を確認
- **シナリオベーステスト**: ユーザーの操作フローに沿ったテストケース設計
- **データフローテスト**: 入力から出力までの一連の処理の確認
- **結合テストが複雑になる場合の対処**:
  - テスト環境の準備が困難 → テストヘルパー関数の作成
  - 非同期処理の多用 → await/async パターンの統一
  - 状態管理の複雑化 → テスト用の初期状態リセット機能の実装

###### 9. Playwright(E2E)テストケース作成
- **E2Eテスト対象の判断**: UIの重要な機能、ユーザーの主要操作フローに限定
- **シナリオ設計**: 実際のユーザー操作に近い形でのテスト設計
- **テストデータ準備**: テスト用のモックデータやテスト環境の整備
- **E2Eテストでの問題対処**:
  - テストが不安定 → 適切な待機処理（waitFor等）の追加
  - 環境依存の問題 → テスト環境の標準化
  - テスト実行時間が長い → 必要最小限のテストケースに絞り込み

#### Tauriのコード修正時

1. コード編集
2. `cargo check --quiet` - エラーがないかチェック（警告は一旦除く）
3. `cargo check` - 警告がないかチェック
4. `cargo clippy` - リンター実行
5. `cargo fmt --all` - フォーマッター実行
6. `cargo test [単体テストファイル名]` - cargo単体テスト実行
7. cargo結合テストケース作成
8. `cargo test [結合テストファイル名]` - cargo結合テスト実行
9. `cargo test` - cargo全テスト実行

##### 詳細手順

###### 1. コード編集
- **設計ドキュメント確認**: `docs/develop/design/backend-tauri/` の関連ドキュメントを確認
- **既存コード分析**: 修正対象モジュールの依存関係と構造を把握
- **エラーハンドリング重視**: Rustの型システムを活用した安全な実装
- **メモリ安全性確保**: 所有権システムを意識した実装
- **動作しない場合の対処**:
  - コンパイラエラーメッセージの詳細確認
  - `cargo check` による段階的なエラー解消
  - `println!` や `dbg!` マクロによるデバッグ出力
  - 単体テストでの小さな単位での動作確認
  - 関連ドキュメントやRust公式ドキュメントの参照

###### 6. cargo単体テストケース作成
- **テスト対象の特定**: 作成・修正した関数、メソッドの動作確認
- **テストケース設計**:
  - 正常系: 期待される入力に対する正しい出力
  - エラー処理: Result型のErr系の適切なハンドリング
  - 境界値テスト: 最大値、最小値、空データ等での動作確認
- **テストが書けない場合の対処**:
  - 外部依存が多い → トレイトによる抽象化とモック化
  - 非同期処理 → tokio::test によるテスト環境整備
  - ファイルI/O → tempfile クレートによる一時ファイル利用

###### 7. cargo結合テストケース作成
- **結合テスト対象の特定**: モジュール間の連携、データベースとの結合等
- **テストシナリオ設計**: 実際の使用パターンに沿ったテストケース
- **テスト環境構築**: テスト用データベース、設定ファイル等の準備
- **結合テストが複雑になる場合の対処**:
  - データベース依存 → テスト用のマイグレーション整備
  - 外部サービス依存 → wiremock 等によるモック化
  - 設定ファイル依存 → テスト専用設定の作成

#### 両方のコード修正時

フロントエンド、Tauriの順番で推薦手順を実施
